---
category: Java
tags:
  - ActiveMQ Active MQ
date: 2020-05-24
title: ActiveMQ入门学习
lang: zh-CN
---
ActiveMQ入门学习

<!-- more -->

## ActiveMQ入门学习

### 1、使用docker安装ActiveMQ

- 获取 ActiveMQ 镜像

  ```bash
  docker pull webcenter/activemq
  ```

  

- 启动 ActiveMQ 命令

  ```
  docker run -d --name activemq -p 61617:61616 -p 8162:8161 webcenter/activemq
  ```

  	- 61616是 ActiveMQ 的容器使用端口（映射为本机61617）
  	- 8161是 web 页面管理端口（映射为本机8162）

### 2、新建MAVEN项目

- 导入相关依赖

  ```xml
      <!-- activemq依赖 -->
      <dependencies>
          <dependency>
              <groupId>org.apache.activemq</groupId>
              <artifactId>activemq-all</artifactId>
              <version>5.15.12</version>
          </dependency>
      </dependencies>
  ```

### 3、创建生产者`AppProducer`

- AppProducer

  ```java
  public class AppProducer {
      private static final String URL = "tcp://xxx.xxx.xxx.xx:61617";
      private static final String TOPIC_NAME = "topic-test";
  
      public static void main(String[] args) throws JMSException {
          //1.创建ConnectionFactory
          ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(URL);
          //2.创建Connection
          Connection connection = connectionFactory.createConnection();
          //3.启动连接
          connection.start();
          //4.创建会话
          Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
          //5.创建一个目标 
          // 队列模式
          Destination destination = session.createQueue(TOPIC_NAME);
          // 主题模式
          //Destination destination = session.createTopic(TOPIC_NAME);
          //6.创建一个生产者
          MessageProducer producer = session.createProducer(destination);
          for (int i = 0; i < 10; i++) {
              //7.创建消息
              TextMessage textMessage = session.createTextMessage("test" + i);
              //8.发布消息
              producer.send(textMessage);
  
              System.out.println("发送消息"+textMessage.getText());
          }
  
          //9.关闭连接
          connection.close();
  
      }
  }
  
  ```

  

### 4、创建消费者`AppConsumer`

- AppConsumer

  ```java
  public class AppConsumer {
      private static final String URL = "tcp://xxx.xxx.xxx.xx:61617";
      private static final String TOPIC_NAME = "topic-test";
  
      public static void main(String[] args) throws JMSException {
          //1. 创建ConnectionFactory
          ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(URL);
          //2. 创建Connection
          Connection connection = connectionFactory.createConnection();
          //3. 启动连接
          connection.start();
          //4. 创建会话
          Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
          //5. 创建一个目标
         	//队列模式
          Destination destination = session.createQueue(TOPIC_NAME);
          // 主题模式
          //Destination destination = session.createTopic(TOPIC_NAME);
          //6. 创建一个消费者
          MessageConsumer consumer = session.createConsumer(destination);
          //7. 创建一个监听器
          consumer.setMessageListener(message -> {
              try {
                  System.out.println("接收消息  = [" + ((TextMessage) message).getText() + "]");
              } catch (JMSException e) {
                  e.printStackTrace();
              }
          });
  
          //8.关闭连接
          //connection.close();
      }
  }
  ```

  

### 5、运行程序

- 队列模式

  直接运行生产者和消费者，与顺序无关

- 主题模式

  必须**先启动消费者**，再启动**生产者**，这里比较坑，之前先启动生产者，消费者一直监听不到，调试了好长时间

### 6、总结

1. 先启动生产者，发布10条消息，然后再启动消费者，这时消费者是不能消费到消息的，因为主题模式中： 只有提前进行订阅的消费者才能成功消费消息。而队列模式消费者不需要提前订阅也可以消费消息
2. 先启动一个消费者，然后再启动生产者发布10条消息，这时消费者成功消费了ActiveMQ服务器中的消息。
3. 先启动两个消费者，然后启动生产者发布10条消息，这时两个消费者都可以消费ActiveMQ服务器中的每一条消息。这就是主题模式的特点： 每个订阅者都可以消费主题模式中的每一条消息。而队列模式中，只能平均消费消息，被别的消费者消费的消息不能重复被其他的消费者消费

### 7、队列模式和主题模式的区别

1. 是否需要提前订阅
   队列模式：消费者不需要提前订阅也可以消费消息
   主题模式：只有提前进行订阅的消费者才能成功消费消息
2. 多个消费者如何分配消息
   队列模式：只能平均消费消息，被别的消费者消费的消息不能重复被其他的消费者消费
   主题模式：每个订阅者都可以消费主题模式中的每一条消息

*部分摘自 https://segmentfault.com/a/1190000014563970#item-5*